package jetbrains.mps.graphLayout.stOrthogonalLayout;

/*Generated by MPS */

import jetbrains.mps.graphLayout.graphLayout.IPointLayouter;
import jetbrains.mps.graphLayout.graphLayout.GraphPointLayout;
import jetbrains.mps.graphLayout.graph.Graph;
import jetbrains.mps.graphLayout.planarGraph.EmbeddedGraph;
import jetbrains.mps.graphLayout.planarization.ShortestPathEmbeddingFinder;
import jetbrains.mps.graphLayout.planarization.BiconnectedInitialEmbeddingFinder;
import jetbrains.mps.graphLayout.planarization.TreeEmbeddingFinder;
import java.util.List;
import jetbrains.mps.graphLayout.graph.Node;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.graphLayout.planarGraph.Dart;
import jetbrains.mps.graphLayout.algorithms.GraphOrientation;
import jetbrains.mps.graphLayout.planarGraph.STPlanarGraph;
import java.util.Map;
import jetbrains.mps.graphLayout.intGeom2D.Rectangle;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.graphLayout.graph.Edge;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.graphLayout.intGeom2D.Point;

public class OrthogonalFromVisibility implements IPointLayouter {
  public OrthogonalFromVisibility() {
  }

  public GraphPointLayout doLayout(Graph graph) {
    /*
      EmbeddedGraph embeddedGraph = new ShortestPathEmbeddingFinder(new BiconnectedInitialEmbeddingFinder()).find(graph);
    */
    EmbeddedGraph embeddedGraph = new TreeEmbeddingFinder().find(graph);
    List<Node> outerNodes = ListSequence.<Node>fromList(new ArrayList<Node>());
    for (Dart dart : ListSequence.<Dart>fromList(embeddedGraph.getOuterFace().getDarts())) {
      ListSequence.<Node>fromList(outerNodes).addElement(dart.getTarget());
    }
    Node s = ListSequence.<Node>fromList(outerNodes).getElement(0);
    Node t = ListSequence.<Node>fromList(outerNodes).getElement((ListSequence.<Node>fromList(outerNodes).count()) / 2);
    GraphOrientation.orientST(graph, s, t);
    STPlanarGraph stPlanarGraph = new STPlanarGraph(embeddedGraph, s, t);
    return doLayout(stPlanarGraph);
  }

  public GraphPointLayout doLayout(STPlanarGraph stPlanarGraph) {
    Graph graph = stPlanarGraph.getGraph();
    Map<Object, Rectangle> visibility = VisibilityRepresentation.getVisibilityRepresentation(stPlanarGraph);
    GraphPointLayout layout = new GraphPointLayout(graph);
    for (Node node : ListSequence.<Node>fromList(graph.getNodes())) {
      Rectangle rect = MapSequence.<Object,Rectangle>fromMap(visibility).get(node);
      List<Integer> edgesX = ListSequence.<Integer>fromList(new ArrayList<Integer>());
      for (Edge edge : ListSequence.<Edge>fromList(node.getEdges())) {
        ListSequence.<Integer>fromList(edgesX).addElement(MapSequence.<Object,Rectangle>fromMap(visibility).get(edge).x);
      }
      edgesX = ListSequence.<Integer>fromList(edgesX).sort(new ISelector<Integer, Comparable<?>>() {
        public Comparable<?> select(Integer it) {
          return it;
        }
      }, true).toListSequence();
      int mid = ListSequence.<Integer>fromList(edgesX).count() / 2;
      layout.setLayoutFor(node, new Point(ListSequence.<Integer>fromList(edgesX).getElement(mid), rect.y));
      /*
        layout.setLayoutFor(node, new Point(rect.x + rect.width / 2, rect.y));
      */
    }
    for (Edge edge : ListSequence.<Edge>fromList(graph.getEdges())) {
      Rectangle rect = MapSequence.<Object,Rectangle>fromMap(visibility).get(edge);
      List<Point> points = ListSequence.<Point>fromList(new ArrayList<Point>());
      ListSequence.<Point>fromList(points).addElement(layout.getLayoutFor(edge.getSource()));
      ListSequence.<Point>fromList(points).addElement(new Point(rect.x, rect.y));
      ListSequence.<Point>fromList(points).addElement(new Point(rect.x, rect.y + rect.height));
      ListSequence.<Point>fromList(points).addElement(layout.getLayoutFor(edge.getTarget()));
      layout.setLayoutFor(edge, points);
    }
    return layout;
  }
}
